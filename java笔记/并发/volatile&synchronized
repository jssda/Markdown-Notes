# Volatile&Synchronized

## 并发编程三大特性

可见性、原子性、有序性

### Volatile

volatile 只能保证并发操作的有序性和可见性, 并不能保证操作的原子性.

在线程执行的时候, 一个共享变量, 会从主存种读取到工作内存中, 进行操作. 当工作内存中操作完之后, 重新刷新到主存. 

JMM 执行指令流程

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的.



1. 每个Java线程都有自己的工作内存，工作内存中的数据并不会实时刷新回主内存，因此在并发情况下，有可能线程A已经修改了成员变量k的值，但是线程B并不能读取到线程A修改后的值，这是因为线程A的工作内存还没有被刷新回主内存，导致线程B无法读取到最新的值。
2. 在工作内存中，每次使用volatile修饰的变量前都必须先从主内存刷新最新的值，这保证了当前线程能看见其他线程对volatile修饰的变量所做的修改后的值。
3. 在工作内存中，每次修改volatile修饰的变量后都必须立刻同步回主内存中，这保证了其他线程可以看到自己对volatile修饰的变量所做的修改。
4. volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。
5. volatile保证可见性，不保证原子性，部分保证有序性（仅保证被volatile修饰的变量）。
6. 指令重排序的目的是为了提高性能，指令重排序仅保证在单线程下不会改变最终的执行结果，但无法保证在多线程下的执行结果。
7. 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止重排序。

## Synchronized

`synchronized`是最常用的同步锁. 底层是通过一个monitor监视器的加减操作, 保证同步. `synchronized`可以保证原子性和可见性. 同时, 因为Synchronized上锁之后只有一个线程能执行, 而单线程不存在有序性的问题. 

- 线程解锁前，必须把共享变量的最新值刷新到主内存中
- 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值(注意：加锁与解锁需要是同一把锁)

执行同步锁的过程

1. 获得互斥锁
2. 清空工作内存
3. 从主内存拷贝变量的最新副本到工作的内存
4. 执行代码
5. 将更改后的共享变量的值刷新到主内存
6. 释放互斥锁

## Lock

`Lock`是`JUC`并发包下的一个锁接口. 他提供了比`Synchronized`更灵活的锁机制. 

提供最主要的方法(lock,trylock,unlock);

## ReentrantLock

ReentrantLock是一个默认非公平的可重入锁. 他的构造方法可传一个boolean变量控制其是否为公平锁. 

`ReentrantLock`:ReentrantLock是k是Lock接口的实现类，基于AQS实现的,在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒。

## ReadWriteLock

可以实现读写锁，当读取的时候线程会获得read锁，其他线程也可以获得read锁同时并发的去读取，但是写程序运行获取到write锁的时候，其他线程是不能进行操作的，因为write是排它锁，而上面介绍的两种不管你是read还是write没有抢到锁的线程都会被阻塞或者中断，它也是个接口，里面定义了两种方法readLock()和writeLock()，他的一个实现类是ReentrantReadWriteLock。