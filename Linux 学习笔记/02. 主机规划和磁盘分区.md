## 各个硬件再Linux中的文件名

![1567646621360](https://raw.githubusercontent.com/jssda/picbed/master/1567646621360.png)

![1567646642451](https://raw.githubusercontent.com/jssda/picbed/master/1567646642451.png)

## 磁盘分区

正常的实体机器使用的磁盘名大多是`/dev/sd[a-]`的磁盘文件名, 虚拟机环境下大多会使用`/dev/vd[a-p]`这种文件名

### MBR 分区

最多只有4个主要的分区, 可以是主分区(Primary)和扩展分区(Extended)分区

可以通过扩展分区进行扩展的的逻辑(Logical)分区.

- 主要分区和扩展分区最多只能由4个
- 扩展分区最多只能有一个(操作系统的限制)
- 逻辑分区是由扩展分区扩展的分区
- 格式化之后, 作为数据存储的是主分区和逻辑分区, 扩展分区不能被格式化.

### GUID partition table, GPT磁盘分区表

新的GPT格式的硬盘不适用扇区区分, 通常使用逻辑区块地址(Logical Block Address, LBA), 来处理。一个GPT的区块默认为512bytes

与MBR仅使用第一个512Byte区块来分区不同, GPT使用了34个LBA区块来记录分区信息. 当让, 只有第一个LBA是分区信息, 其他的33个都是第一个的备份.

GPT格式硬盘, 最多可分区128个.  每个都是主分区.

## 开机流程中的BIOS和UEFI

### BIOS搭配MBR/GPT的开机流程

计算机通电–--加载BIOS---BIOS读取CMOS各项记录参数---分析存储设备—-读取启动盘中的MBR–--读取前446Byte的开机管理程序---开机管理程序加载核心文件

1. BIOS: 开机主动执行的程序, 会认识第一个可开机的装置
2. MBR: 第一个可开机装置的第一个扇区内的主要启动记录区块, 内含开机管理程序
3. 开机管理程序(Boot Loader): 一支可读取核心文件来执行的软件
4. 核心文件: 开始操作系统的功能.

Boot Loader功能:

1. 提供选项: 用户可以选择不同的开机项目, 这也是多重引导的功能
2. 载入核心文件: 直接指向开机的程序区段来开始操作系统
3. 转交给其他Loader: 将开机转交给其他的Loader负责

由于第三点功能, 所以开始的时候可以选择不同的加载程序. 每个分区的启动扇区都会有其他的开机管理程序.

### 多重引导原理

![1567648940691](https://raw.githubusercontent.com/jssda/picbed/master/1567648940691.png)

1. 每个分区都拥有自己的启动扇区(boot sector)
2. 图中的系统分区为第一和第二个分区
3. 实际可开机的核心文件是放置到各个分区的分区中的
4. Loader只会认识自己的系统分区内的开机文件, 以及其他的Loader而已
5. Loader可直接指向或者是间接将管理权交给其他的管理程序

### UEFI BIOS 搭配GPT开机流程

![1567649250075](https://raw.githubusercontent.com/jssda/picbed/master/1567649250075.png)

与BIOS比较, UEFI可以直接取得GPT的分区表, 不过最好还是拥有BIOS boot启动分区. 同时, 为了兼容windows, 并且提供其他厂商所使用的UEFI应用程序的存储空间, 必须格式化一个vfat的文件系统, 大约提供512M到1G的容量, 让UEFI执行更加方便.

### 文件系统和目录树的关系(挂载)

所谓的挂载,就是利用一个目录当成进入点, 将磁盘分区槽的数据放置在该目录下. 也就是说, 进入该目录就是读取该分区槽的意思.

所以, 根目录必须挂载到一个分区. 其他目录可以用户自己选择挂载到哪个分区.

## 分区

### 最简单的分区

仅分出根分区和交换分区(/swap). 预留一些空间供后续练习使用

### 稍微麻烦一点的分区

分出读写频繁的一些分区

- /boot
- /
- /home
- /var
- Swap

